# -*- coding: utf-8 -*-
"""MANSIPATIL_CODINGASSIGNMENT2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cFaOL4fPl5tGqeIyxOqipwjCVg3Ludgg
"""

!pip install pycryptodome

from Crypto.Cipher import AES, DES, DES3
from Crypto.Util.Padding import pad, unpad
from Crypto.Random import get_random_bytes
from base64 import b64encode, b64decode
import string
import random
import math

# Substitution Cipher - Shift Cipher
def shift_cipher_encrypt(message, shift):
    encrypted_message = ''
    for char in message:
        if char.isalpha():
            shift_amount = 65 if char.isupper() else 97
            encrypted_char = chr((ord(char) - shift_amount + shift) % 26 + shift_amount)
            encrypted_message += encrypted_char
        else:
            encrypted_message += char
    return encrypted_message

def shift_cipher_decrypt(encrypted_message, shift):
    return shift_cipher_encrypt(encrypted_message, -shift)

# Substitution Cipher - Permutation Cipher
def permutation_cipher_encrypt(message):
    alphabet = list(string.ascii_lowercase)
    shuffled_alphabet = list(string.ascii_lowercase)
    random.shuffle(shuffled_alphabet)
    mapping = dict(zip(alphabet, shuffled_alphabet))

    encrypted_message = ''
    for char in message:
        if char.isalpha():
            encrypted_message += mapping[char.lower()].upper() if char.isupper() else mapping[char]
        else:
            encrypted_message += char
    return encrypted_message

def permutation_cipher_decrypt(encrypted_message, mapping):
    decrypted_message = ''
    for char in encrypted_message:
        if char.isalpha():
            decrypted_message += mapping[char.lower()].upper() if char.isupper() else mapping[char]
        else:
            decrypted_message += char
    return decrypted_message

# Transposition Cipher - Simple Transposition

def simple_transposition_encrypt(plaintext, key):
    key_order = sorted(range(len(key)), key=lambda k: key[k])
    ciphertext = ''.join(plaintext[i] for i in key_order)
    return ciphertext

def simple_transposition_decrypt(ciphertext, key):
    key_order = sorted(range(len(key)), key=lambda k: key[k])
    plaintext = [''] * len(ciphertext)
    for i, c in enumerate(ciphertext):
        plaintext[key_order[i % len(key)]] += c
    return ''.join(plaintext)

# Transposition Cipher - double Transposition
def double_transposition_encrypt(plaintext, key1, key2):
    encrypted_once = simple_transposition_encrypt(plaintext, key1)
    ciphertext = simple_transposition_encrypt(encrypted_once, key2)
    return ciphertext

def double_transposition_decrypt(ciphertext, key1, key2):
    decrypted_once = simple_transposition_decrypt(ciphertext, key2)
    plaintext = simple_transposition_decrypt(decrypted_once, key1)
    return plaintext


# Vigenère Cipher
def vigenere_cipher_encrypt(plaintext, key):
    key = key.upper()
    key_length = len(key)
    ciphertext = ''
    for i, char in enumerate(plaintext):
        if char.isalpha():
            shift = ord(key[i % key_length]) - 65
            if char.isupper():
                encrypted_char = chr(((ord(char) - 65 + shift) % 26) + 65)
            else:
                encrypted_char = chr(((ord(char) - 97 + shift) % 26) + 97)
            ciphertext += encrypted_char
        else:
            ciphertext += char
    return ciphertext

def vigenere_cipher_decrypt(ciphertext, key):
    key = key.upper()
    key_length = len(key)
    plaintext = ''
    for i, char in enumerate(ciphertext):
        if char.isalpha():
            shift = ord(key[i % key_length]) - 65
            if char.isupper():
                decrypted_char = chr(((ord(char) - 65 - shift) % 26) + 65)
            else:
                decrypted_char = chr(((ord(char) - 97 - shift) % 26) + 97)
            plaintext += decrypted_char
        else:
            plaintext += char
    return plaintext


# Encryption modes
modes = {
    'ECB': AES.MODE_ECB,
    'CBC': AES.MODE_CBC,
}
# Encryption function for AES-128 ECB mode
def encrypt_aes_ecb(message, key):
    cipher = AES.new(key, AES.MODE_ECB)
    return b64encode(cipher.encrypt(pad(message.encode(), AES.block_size))).decode()

# Decryption function for AES-128 ECB mode
def decrypt_aes_ecb(ciphertext, key):
    ciphertext = b64decode(ciphertext)
    cipher = AES.new(key, AES.MODE_ECB)
    return unpad(cipher.decrypt(ciphertext), AES.block_size).decode()

# Encryption function for DES ECB mode
def encrypt_des_ecb(message, key):
    cipher = DES.new(key, DES.MODE_ECB)
    return b64encode(cipher.encrypt(pad(message.encode(), DES.block_size))).decode()

# Decryption function for DES ECB mode
def decrypt_des_ecb(ciphertext, key):
    ciphertext = b64decode(ciphertext)
    cipher = DES.new(key, DES.MODE_ECB)
    return unpad(cipher.decrypt(ciphertext), DES.block_size).decode()

# Encryption function for 3DES ECB mode
def encrypt_3des_ecb(message, key):
    cipher = DES3.new(key, DES3.MODE_ECB)
    return b64encode(cipher.encrypt(pad(message.encode(), DES3.block_size))).decode()

# Decryption function for 3DES ECB mode
def decrypt_3des_ecb(ciphertext, key):
    ciphertext = b64decode(ciphertext)
    cipher = DES3.new(key, DES3.MODE_ECB)
    return unpad(cipher.decrypt(ciphertext), DES3.block_size).decode()

# Encryption function for AES-128 CBC mode
def encrypt_aes_cbc(message, key):
    iv = get_random_bytes(AES.block_size)
    cipher = AES.new(key, AES.MODE_CBC, iv)
    ciphertext = cipher.encrypt(pad(message.encode(), AES.block_size))
    return b64encode(iv + ciphertext).decode()

# Decryption function for AES-128 CBC mode
def decrypt_aes_cbc(ciphertext, key):
    ciphertext = b64decode(ciphertext)
    iv = ciphertext[:AES.block_size]
    cipher = AES.new(key, AES.MODE_CBC, iv)
    return unpad(cipher.decrypt(ciphertext[AES.block_size:]), AES.block_size).decode()

# Encryption function for DES CBC mode
def encrypt_des_cbc(message, key):
    iv = get_random_bytes(DES.block_size)
    cipher = DES.new(key, DES.MODE_CBC, iv)
    ciphertext = cipher.encrypt(pad(message.encode(), DES.block_size))
    return b64encode(iv + ciphertext).decode()

# Decryption function for DES CBC mode
def decrypt_des_cbc(ciphertext, key):
    ciphertext = b64decode(ciphertext)
    iv = ciphertext[:DES.block_size]
    cipher = DES.new(key, DES.MODE_CBC, iv)
    return unpad(cipher.decrypt(ciphertext[DES.block_size:]), DES.block_size).decode()

# Encryption function for 3DES CBC mode
def encrypt_3des_cbc(message, key):
    iv = get_random_bytes(DES3.block_size)
    cipher = DES3.new(key, DES3.MODE_CBC, iv)
    ciphertext = cipher.encrypt(pad(message.encode(), DES3.block_size))
    return b64encode(iv + ciphertext).decode()

# Decryption function for 3DES CBC mode
def decrypt_3des_cbc(ciphertext, key):
    ciphertext = b64decode(ciphertext)
    iv = ciphertext[:DES3.block_size]
    cipher = DES3.new(key, DES3.MODE_CBC, iv)
    return unpad(cipher.decrypt(ciphertext[DES3.block_size:]), DES3.block_size).decode()

# Encryption keys (default keys)
default_keys = {
    'AES-128': b'Thisis16-bytekey',
    'DES': b'8bytekey',
    '3DES': b'This is a 24-byte 3DESke'
}
# Error handling for invalid input
def validate_input(message, key):
    if not message:
        raise ValueError("Message cannot be empty, please enter the message.")
    if not key:
        raise ValueError("Key cannot be empty.")

def main():
    while True:
        print("\n Encryption Techniques:")
        print("1. Substitution Cipher")
        print("\t- Shift Cipher")
        print("\t- Permutation Cipher")
        print("2. Transposition Ciphers")
        print("\t- Simple Transposition")
        print("\t- Double Transposition")
        print("3. Vigenère Cipher")
        print("4. Different encryption algorithms (AES-128, DES, 3DES)")
        print("5. Different encryption modes (ECB, CBC)")
        print("6. Exit")

        choice = input("Enter your choice: ").strip().lower()
        if choice == "1":
            print("The Substitution Cipher has been selected.")
            sub_choice = input("Pick a shift or permutation technique for the substitution cipher.(shift or permutation): ").strip().lower()
            message = input("Type the content that you want to encrypt.: ")

            if sub_choice == "shift":
                shift = int(input("Enter the shift value: "))
                encrypted_message = shift_cipher_encrypt(message, shift)
                print("Encrypted Message:", encrypted_message)
                while True:
                  decrypt_choice = input("Would you like to decrypt this message? (yes or no): ").strip().lower()
                  if decrypt_choice == "yes":
                      decryption_option = input(" Which would you prefer-using the ciphertext or a key for decryption?(key/ciphertext): ").strip().lower()
                      if decryption_option == "key":
                          shift_decrypt_choice = int(input("Enter the decryption's shift value : "))
                          decrypted_message = shift_cipher_decrypt(encrypted_message, shift_decrypt_choice) if sub_choice == "shift" else permutation_cipher_decrypt(encrypted_message, mapping)
                          print("Decrypted Message:", decrypted_message)
                          break
                      elif decryption_option == "ciphertext":
                          ciphertext = input("To decrypt, enter the ciphertex.: ")
                          decrypted_message = shift_cipher_decrypt(ciphertext, shift) if sub_choice == "shift" else permutation_cipher_decrypt(ciphertext, mapping)
                          print("Decrypted Message:", decrypted_message)
                          break
                      else:
                          print("Not a valid option. Could you please try again?.")
                          break
                  elif decrypt_choice == "no":
                      break
                  else:
                      print("Not a valid option. Please type yes or no. ")


            elif sub_choice == "permutation":
                encrypted_message = permutation_cipher_encrypt(message)
                print("Encrypted Message:", encrypted_message)
                decrypt_choice = input("Do you want to decrypt this message? (yes/no): ").strip().lower()
                if decrypt_choice == "yes":
                    mapping = {v: k for k, v in zip(string.ascii_lowercase, encrypted_message.lower())}
                    decrypted_message = permutation_cipher_decrypt(encrypted_message, mapping)
                    print("Decrypted Message:", decrypted_message)

            else:
                print("Invalid choice. Please try again.")


        elif choice == "2":
            print("You have selected Transposition Ciphers.")
            choice = input("Choose Transposition Cipher technique (simple/double): ").strip().lower()
            message = input("Enter the message that you want to encrypted: ")
            if choice.lower() == 'simple':

              key = input("Enter the key for simple transposition: ")
              encrypted_message = simple_transposition_encrypt(message, key)
              print("Encrypted Message:", encrypted_message)
              decrypt_choice = input("Do you want to decrypt this message? (yes/no): ")
              if decrypt_choice.lower() == 'yes':
                 decrypted_message = simple_transposition_decrypt(encrypted_message, key)
                 print("Decrypted Message:", decrypted_message)

            elif choice.lower() == 'double':
                key1 = input("For double transposition, Enter the first key: ")
                key2 = input("For double transposition, Enter the second key: ")
                encrypted_message = double_transposition_encrypt(message, key1, key2)
                print("Encrypted Message:", encrypted_message)
                decrypt_choice = input("Do you want to decrypt this message? (yes/no): ").strip().lower()
                if decrypt_choice.lower() == "yes":
                  decrypted_message = double_transposition_decrypt(encrypted_message, key1, key2)
                  print("Decrypted Message:", decrypted_message)

            else:
                print("Not a valid option. Try again, please.")



        elif choice == "3":
            print("You've chosen Vigenère Cipher.")
            message = input("Enter the message to encrypt: ")
            key = input("Enter the key for Vigenère Cipher: ")
            encrypted_message = vigenere_cipher_encrypt(message, key)
            print("Encrypted Message:", encrypted_message)

            decrypt_choice = input("Do you want to decrypt this message? (yes/no): ").strip().lower()
            if decrypt_choice == "yes":
                decryption_choice = input("Which would you prefer- ciphertext or a key for decryption? (key/ciphertext): ").strip().lower()
                if decryption_choice == "key":
                    key = input("Enter the key for decryption: ")
                    decrypted_message = vigenere_cipher_decrypt(encrypted_message, key)
                    print("Decrypted Message:", decrypted_message)
                elif decryption_choice == "ciphertext":
                    ciphertext = input("Enter the ciphertext to decrypt: ")
                    decrypted_message = vigenere_cipher_decrypt(ciphertext, key)
                    print("Decrypted Message:", decrypted_message)
                else:
                    print("Your selection is invalid")

        elif choice == "4":   #choice 4
            try:

              print("You've chosen Different encryption algorithms(AES-128,DES, 3DES).")
              algorithm_choice = input("Enter the encryption algorithm (AES-128, DES, 3DES): ").strip().upper()
              mode = input("Enter encryption mode (ECB, CBC): ").strip().upper()
              message = input("Enter the message that you want to encrypted: ")


              # Ask user for key or use default key

              key_choice = input("Would you prefer to enter a custom key? (yes/no): ").strip().lower()
              if key_choice == "yes":
                  key = input("Enter the encryption key: ")
                  key = key.encode()
                  if algorithm_choice == 'AES-128' and len(key) != 16:
                      print("The key's length is invalid. To use AES encryption, the key must be 16 bytes long.")
                      continue
                  elif algorithm_choice == 'DES' and len(key) != 8:
                      print("The key's length is invalid. To use DES encryption, the key must be 8 bytes long.")
                      continue
                  elif algorithm_choice == '3DES' and len(key) != 24:
                      print("The key's length is invalid. To use 3DES encryption, the key must be 24 bytes long")
                      continue

              else:
                  if algorithm_choice in default_keys:
                      key = default_keys[algorithm_choice]
                      print("Using the default key.:", key.decode())
                  else:
                      print("Default key not available for chosen algorithm.")
                      continue

              if algorithm_choice == 'AES-128':
                  algorithm = AES
              elif algorithm_choice == 'DES':
                  algorithm = DES
              elif algorithm_choice == '3DES':
                  algorithm = DES3
              else:
                  print("Invalid encryption algorithm.")
                  continue

              if mode == 'ECB':
                  if algorithm_choice == 'AES-128':
                      validate_input(message, key)
                      ciphertext = encrypt_aes_ecb(message, key)
                      print("Encrypted Message:", ciphertext)

                  elif algorithm_choice == 'DES':
                      validate_input(message, key)
                      ciphertext = encrypt_des_ecb(message, key)
                      print("Encrypted Message:", ciphertext)

                  elif algorithm_choice == '3DES':
                      validate_input(message, key)
                      ciphertext = encrypt_3des_ecb(message, key)
                      print("Encrypted Message:", ciphertext)

              elif mode == 'CBC':
                  if algorithm_choice == 'AES-128':
                      validate_input(message, key)
                      ciphertext = encrypt_aes_cbc(message, key)
                      print("Encrypted Message:", ciphertext)

                  elif algorithm_choice == 'DES':
                      validate_input(message, key)
                      ciphertext = encrypt_des_cbc(message, key)
                      print("Encrypted Message:", ciphertext)

                  elif algorithm_choice == '3DES':
                      validate_input(message, key)
                      ciphertext = encrypt_3des_cbc(message, key)
                      print("Encrypted Message:", ciphertext)

              decrypt_choice = input("Do you want to decrypt this message? (yes/no): ").strip().lower()
              if decrypt_choice == "yes":
                  decryption_choice = input("Which would you prefer-using the ciphertext or a key for decryption? (key/ciphertext): ").strip().lower()
                  if decryption_choice == "key":
                      key_choice = input("Do you want to use a custom key or default key? (custom/default): ").strip().lower()
                      if key_choice == "custom":
                          decryption_key = input("Enter the decryption key: ")
                          decryption_key = decryption_key.encode()  # Convert the key to bytes
                      elif key_choice == "default":
                          decryption_key = key
                      else:
                          print("Please try again. Your selection is invalid.")
                          continue

                      if algorithm_choice == 'AES-128':
                          if mode == 'ECB':
                              plaintext = decrypt_aes_ecb(ciphertext, decryption_key)
                              print("Decrypted Message:", plaintext)
                          elif mode == 'CBC':
                              plaintext = decrypt_aes_cbc(ciphertext, decryption_key)
                              print("Decrypted Message:", plaintext)

                      elif algorithm_choice == 'DES':
                          if mode == 'ECB':
                              plaintext = decrypt_des_ecb(ciphertext, decryption_key)
                              print("Decrypted Message:", plaintext)
                          elif mode == 'CBC':
                              plaintext = decrypt_des_cbc(ciphertext, decryption_key)
                              print("Decrypted Message:", plaintext)

                      elif algorithm_choice == '3DES':
                          if mode == 'ECB':
                              plaintext = decrypt_3des_ecb(ciphertext, decryption_key)
                              print("Decrypted Message:", plaintext)
                          elif mode == 'CBC':
                              plaintext = decrypt_3des_cbc(ciphertext, decryption_key)
                              print("Decrypted Message:", plaintext)

                  elif decryption_choice == "ciphertext":
                      ciphertext = input("Enter the ciphertext to decrypt: ")

                      if algorithm_choice == 'AES-128':
                          if mode == 'ECB':
                              plaintext = decrypt_aes_ecb(ciphertext, key)
                              print("Decrypted Message:", plaintext)
                          elif mode == 'CBC':
                              plaintext = decrypt_aes_cbc(ciphertext, key)
                              print("Decrypted Message:", plaintext)

                      elif algorithm_choice == 'DES':
                          if mode == 'ECB':
                              plaintext = decrypt_des_ecb(ciphertext, key)
                              print("Decrypted Message:", plaintext)
                          elif mode == 'CBC':
                              plaintext = decrypt_des_cbc(ciphertext, key)
                              print("Decrypted Message:", plaintext)

                      elif algorithm_choice == '3DES':
                          if mode == 'ECB':
                              plaintext = decrypt_3des_ecb(ciphertext, key)
                              print("Decrypted Message:", plaintext)
                          elif mode == 'CBC':
                              plaintext = decrypt_3des_cbc(ciphertext, key)
                              print("Decrypted Message:", plaintext)

                  else:
                      print("Please try again. Your choice is invalid..")
            except ValueError as e:
                   print("Error:", e)

        elif choice == "5":
            print("Option 4 is interconnected with this option. To use different encryption modes with different encryption methods, please select option 4.")

        elif choice == "6":
            print("Exiting program.")
            print("Exit the loop and end the program")
            break
        else:
            print("Invalid choice. Please try again.")

if __name__ == "__main__":
    main()

